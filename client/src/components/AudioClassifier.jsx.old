import React, { useEffect, useState, useRef } from 'react';
import Meyda from 'meyda';

/**
 * éŸ³é¢‘åˆ†ç±»å™¨ç»„ä»¶
 * åŸºäº MFCC ç‰¹å¾è¿›è¡Œç®€å•çš„éŸ³é¢‘åˆ†ç±»ï¼ˆéŸ³ä¹ vs è¯­éŸ³ï¼‰
 */
function AudioClassifier({ audioRef }) {
  const [classification, setClassification] = useState(null);
  const [confidence, setConfidence] = useState(0);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [features, setFeatures] = useState(null);
  
  const meydaAnalyzerRef = useRef(null);
  const audioContextRef = useRef(null);
  const sourceRef = useRef(null);
  const samplesRef = useRef([]);

  useEffect(() => {
    if (!audioRef) return;

    const handlePlay = () => {
      try {
        setIsAnalyzing(true);
        samplesRef.current = [];

        // åˆå§‹åŒ– AudioContext
        if (!audioContextRef.current) {
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        }

        if (!sourceRef.current) {
          sourceRef.current = audioContextRef.current.createMediaElementSource(audioRef);
        }

        const context = audioContextRef.current;
        const source = sourceRef.current;
        const analyzer = context.createAnalyser();
        
        analyzer.fftSize = 2048;
        source.connect(analyzer);
        analyzer.connect(context.destination);

        if (context.state === 'suspended') {
          context.resume();
        }

        // åˆ›å»º Meyda åˆ†æå™¨
        meydaAnalyzerRef.current = Meyda.createMeydaAnalyzer({
          audioContext: context,
          source: source,
          bufferSize: 512,
          featureExtractors: [
            'mfcc',
            'spectralCentroid',
            'spectralFlatness',
            'zcr',
            'rms',
          ],
          callback: (extractedFeatures) => {
            // æ”¶é›†æ ·æœ¬
            samplesRef.current.push(extractedFeatures);
            
            // æ¯æ”¶é›† 20 ä¸ªæ ·æœ¬è¿›è¡Œä¸€æ¬¡åˆ†ç±»
            if (samplesRef.current.length >= 20) {
              classifyAudio(samplesRef.current);
              samplesRef.current = samplesRef.current.slice(-10); // ä¿ç•™æœ€è¿‘ 10 ä¸ª
            }

            setFeatures(extractedFeatures);
          },
        });

        meydaAnalyzerRef.current.start();
        console.log('âœ… åˆ†ç±»å™¨å¯åŠ¨');

      } catch (err) {
        console.error('âŒ åˆ†ç±»å™¨å¯åŠ¨å¤±è´¥:', err);
        setIsAnalyzing(false);
      }
    };

    const handleStop = () => {
      setIsAnalyzing(false);
      if (meydaAnalyzerRef.current) {
        meydaAnalyzerRef.current.stop();
      }
    };

    audioRef.addEventListener('play', handlePlay);
    audioRef.addEventListener('pause', handleStop);
    audioRef.addEventListener('ended', handleStop);

    return () => {
      audioRef.removeEventListener('play', handlePlay);
      audioRef.removeEventListener('pause', handleStop);
      audioRef.removeEventListener('ended', handleStop);
      
      if (meydaAnalyzerRef.current) {
        meydaAnalyzerRef.current.stop();
      }
    };
  }, [audioRef]);

  /**
   * ç®€å•çš„éŸ³é¢‘åˆ†ç±»ç®—æ³•
   * åŸºäº MFCC å’Œå…¶ä»–éŸ³é¢‘ç‰¹å¾çš„ç»Ÿè®¡ç‰¹æ€§
   */
  const classifyAudio = (samples) => {
    if (samples.length === 0) return;

    // è®¡ç®—ç‰¹å¾çš„å¹³å‡å€¼
    const avgSpectralCentroid = samples.reduce((sum, s) => sum + (s.spectralCentroid || 0), 0) / samples.length;
    const avgSpectralFlatness = samples.reduce((sum, s) => sum + (s.spectralFlatness || 0), 0) / samples.length;
    const avgZCR = samples.reduce((sum, s) => sum + (s.zcr || 0), 0) / samples.length;
    const avgRMS = samples.reduce((sum, s) => sum + (s.rms || 0), 0) / samples.length;

    // è®¡ç®— MFCC çš„æ–¹å·®ï¼ˆéŸ³ä¹é€šå¸¸æ–¹å·®è¾ƒå¤§ï¼‰
    const mfccVariances = [];
    if (samples[0].mfcc) {
      for (let i = 0; i < samples[0].mfcc.length; i++) {
        const values = samples.map(s => s.mfcc[i]);
        const mean = values.reduce((a, b) => a + b, 0) / values.length;
        const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
        mfccVariances.push(variance);
      }
    }

    const avgMFCCVariance = mfccVariances.reduce((a, b) => a + b, 0) / mfccVariances.length;

    // åˆ†ç±»è§„åˆ™ï¼ˆåŸºäºç»éªŒå€¼ï¼‰
    let musicScore = 0;
    let speechScore = 0;

    // è§„åˆ™ 1: é¢‘è°±è´¨å¿ƒ
    // éŸ³ä¹é€šå¸¸é¢‘è°±è´¨å¿ƒè¾ƒé«˜ï¼ˆæ›´å¤šé«˜é¢‘æˆåˆ†ï¼‰
    if (avgSpectralCentroid > 2000) {
      musicScore += 2;
    } else {
      speechScore += 2;
    }

    // è§„åˆ™ 2: é¢‘è°±å¹³å¦åº¦
    // è¯­éŸ³é€šå¸¸é¢‘è°±æ›´å¹³å¦ï¼ˆæ¥è¿‘ç™½å™ªå£°ï¼‰
    if (avgSpectralFlatness > 0.3) {
      speechScore += 2;
    } else {
      musicScore += 2;
    }

    // è§„åˆ™ 3: è¿‡é›¶ç‡
    // è¯­éŸ³é€šå¸¸è¿‡é›¶ç‡è¾ƒé«˜
    if (avgZCR > 0.1) {
      speechScore += 1;
    } else {
      musicScore += 1;
    }

    // è§„åˆ™ 4: MFCC æ–¹å·®
    // éŸ³ä¹çš„ MFCC æ–¹å·®é€šå¸¸æ›´å¤§ï¼ˆæ›´å¤šå˜åŒ–ï¼‰
    if (avgMFCCVariance > 10) {
      musicScore += 2;
    } else {
      speechScore += 2;
    }

    // è§„åˆ™ 5: RMSï¼ˆéŸ³é‡ï¼‰
    // éŸ³ä¹é€šå¸¸éŸ³é‡æ›´ç¨³å®š
    if (avgRMS > 0.02 && avgRMS < 0.1) {
      musicScore += 1;
    }

    // è®¡ç®—æœ€ç»ˆåˆ†ç±»
    const totalScore = musicScore + speechScore;
    const musicConfidence = (musicScore / totalScore) * 100;
    const speechConfidence = (speechScore / totalScore) * 100;

    if (musicScore > speechScore) {
      setClassification('éŸ³ä¹ (Music)');
      setConfidence(musicConfidence);
    } else {
      setClassification('è¯­éŸ³ (Speech)');
      setConfidence(speechConfidence);
    }

    console.log('ğŸ¯ åˆ†ç±»ç»“æœ:', {
      classification: musicScore > speechScore ? 'éŸ³ä¹' : 'è¯­éŸ³',
      musicScore,
      speechScore,
      confidence: Math.max(musicConfidence, speechConfidence),
      features: {
        avgSpectralCentroid,
        avgSpectralFlatness,
        avgZCR,
        avgMFCCVariance,
      },
    });
  };

  if (!isAnalyzing && !classification) return null;

  return (
    <div style={styles.container}>
      <div style={styles.header}>
        <h3 style={styles.title}>ğŸ¯ éŸ³é¢‘åˆ†ç±»å™¨ (Audio Classifier)</h3>
        {isAnalyzing && <span style={styles.badge}>åˆ†æä¸­...</span>}
      </div>

      {classification && (
        <div style={styles.result}>
          <div style={styles.classLabel}>
            åˆ†ç±»ç»“æœ: <strong>{classification}</strong>
          </div>
          <div style={styles.confidenceBar}>
            <div style={styles.confidenceLabel}>
              ç½®ä¿¡åº¦: {confidence.toFixed(1)}%
            </div>
            <div style={styles.progressBar}>
              <div 
                style={{
                  ...styles.progress,
                  width: `${confidence}%`,
                  background: confidence > 70 ? '#28a745' : confidence > 50 ? '#ffc107' : '#dc3545',
                }}
              />
            </div>
          </div>
        </div>
      )}

      {features && (
        <div style={styles.features}>
          <h4 style={styles.subtitle}>ç‰¹å¾å€¼:</h4>
          <div style={styles.featureGrid}>
            <div style={styles.featureItem}>
              <span style={styles.featureName}>é¢‘è°±è´¨å¿ƒ:</span>
              <span style={styles.featureValue}>
                {features.spectralCentroid?.toFixed(2) || 'N/A'} Hz
              </span>
            </div>
            <div style={styles.featureItem}>
              <span style={styles.featureName}>é¢‘è°±å¹³å¦åº¦:</span>
              <span style={styles.featureValue}>
                {features.spectralFlatness?.toFixed(4) || 'N/A'}
              </span>
            </div>
            <div style={styles.featureItem}>
              <span style={styles.featureName}>è¿‡é›¶ç‡:</span>
              <span style={styles.featureValue}>
                {features.zcr?.toFixed(4) || 'N/A'}
              </span>
            </div>
            <div style={styles.featureItem}>
              <span style={styles.featureName}>RMS éŸ³é‡:</span>
              <span style={styles.featureValue}>
                {features.rms?.toFixed(4) || 'N/A'}
              </span>
            </div>
          </div>
        </div>
      )}

      <div style={styles.info}>
        <p style={styles.infoText}>
          ğŸ’¡ <strong>åˆ†ç±»è¯´æ˜:</strong>
          <br/>
          æœ¬åˆ†ç±»å™¨åŸºäº MFCC å’ŒéŸ³é¢‘ç‰¹å¾è¿›è¡Œç®€å•çš„äºŒåˆ†ç±»ï¼ˆéŸ³ä¹ vs è¯­éŸ³ï¼‰ã€‚
          <br/>
          åˆ¤æ–­ä¾æ®ï¼šé¢‘è°±è´¨å¿ƒã€é¢‘è°±å¹³å¦åº¦ã€è¿‡é›¶ç‡ã€MFCC æ–¹å·®ç­‰ã€‚
        </p>
      </div>
    </div>
  );
}

const styles = {
  container: {
    padding: '1.5rem',
    background: 'white',
    borderRadius: '12px',
    border: '2px solid #667eea',
    boxShadow: '0 4px 6px rgba(0,0,0,0.1)',
  },
  header: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: '1.5rem',
  },
  title: {
    margin: 0,
    color: '#333',
    fontSize: '1.25rem',
  },
  badge: {
    background: '#667eea',
    color: 'white',
    padding: '0.375rem 0.875rem',
    borderRadius: '12px',
    fontSize: '0.85rem',
    fontWeight: '600',
  },
  result: {
    background: '#f8f9fa',
    padding: '1.5rem',
    borderRadius: '8px',
    marginBottom: '1.5rem',
  },
  classLabel: {
    fontSize: '1.25rem',
    marginBottom: '1rem',
    color: '#333',
  },
  confidenceBar: {
    marginTop: '1rem',
  },
  confidenceLabel: {
    fontSize: '0.95rem',
    color: '#666',
    marginBottom: '0.5rem',
  },
  progressBar: {
    width: '100%',
    height: '24px',
    background: '#e9ecef',
    borderRadius: '12px',
    overflow: 'hidden',
  },
  progress: {
    height: '100%',
    transition: 'width 0.3s ease',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    color: 'white',
    fontWeight: 'bold',
    fontSize: '0.85rem',
  },
  features: {
    marginBottom: '1.5rem',
  },
  subtitle: {
    margin: '0 0 1rem 0',
    color: '#555',
    fontSize: '1rem',
  },
  featureGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(2, 1fr)',
    gap: '0.75rem',
  },
  featureItem: {
    display: 'flex',
    justifyContent: 'space-between',
    padding: '0.75rem',
    background: '#f8f9fa',
    borderRadius: '6px',
  },
  featureName: {
    color: '#666',
    fontSize: '0.9rem',
  },
  featureValue: {
    fontWeight: 'bold',
    color: '#007bff',
    fontSize: '0.9rem',
  },
  info: {
    background: '#e7f3ff',
    padding: '1rem',
    borderRadius: '8px',
    border: '1px solid #b3d9ff',
  },
  infoText: {
    margin: 0,
    fontSize: '0.9rem',
    color: '#004085',
    lineHeight: '1.6',
  },
};

export default AudioClassifier;