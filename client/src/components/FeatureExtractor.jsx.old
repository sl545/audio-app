import React, { useEffect, useState, useRef } from 'react';
import Meyda from 'meyda';

function FeatureExtractor({ audioRef }) {
  const [features, setFeatures] = useState(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [analysisHistory, setAnalysisHistory] = useState([]);
  const [error, setError] = useState(null);
  
  const meydaAnalyzerRef = useRef(null);
  const canvasRef = useRef(null);
  const audioContextRef = useRef(null);
  const sourceRef = useRef(null);

  useEffect(() => {
    if (!audioRef) {
      console.log('âš ï¸ FeatureExtractor: audioRef ä¸ºç©º');
      return;
    }

    console.log('ğŸµ FeatureExtractor: åˆå§‹åŒ–');

    let analyzer;

    const initAudioContext = () => {
      try {
        // åˆ›å»º AudioContextï¼ˆåªåˆ›å»ºä¸€æ¬¡ï¼‰
        if (!audioContextRef.current) {
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
          console.log('âœ… AudioContext åˆ›å»ºæˆåŠŸ');
        }

        const context = audioContextRef.current;

        // åˆ›å»º MediaElementSourceï¼ˆåªåˆ›å»ºä¸€æ¬¡ï¼‰
        if (!sourceRef.current) {
          sourceRef.current = context.createMediaElementSource(audioRef);
          console.log('âœ… MediaElementSource åˆ›å»ºæˆåŠŸ');
        }

        const source = sourceRef.current;

        // åˆ›å»º Analyzer
        analyzer = context.createAnalyser();
        analyzer.fftSize = 2048;

        // è¿æ¥ï¼šsource â†’ analyzer â†’ destination
        source.connect(analyzer);
        analyzer.connect(context.destination);

        console.log('âœ… éŸ³é¢‘èŠ‚ç‚¹è¿æ¥æˆåŠŸ');
      } catch (err) {
        console.error('âŒ AudioContext åˆå§‹åŒ–å¤±è´¥:', err);
        setError(err.message);
      }
    };

    // éŸ³é¢‘æ’­æ”¾æ—¶å¼€å§‹åˆ†æ
    const handlePlay = () => {
      try {
        console.log('â–¶ï¸ å¼€å§‹éŸ³é¢‘åˆ†æ');
        setIsAnalyzing(true);
        setError(null);

        if (!audioContextRef.current || !sourceRef.current) {
          initAudioContext();
        }

        // æ¢å¤ AudioContextï¼ˆå¦‚æœè¢«æš‚åœï¼‰
        if (audioContextRef.current.state === 'suspended') {
          audioContextRef.current.resume();
        }

        // åˆ›å»º Meyda åˆ†æå™¨
        meydaAnalyzerRef.current = Meyda.createMeydaAnalyzer({
          audioContext: audioContextRef.current,
          source: sourceRef.current,
          bufferSize: 512,
          featureExtractors: [
            'mfcc',
            'zcr',
            'spectralCentroid',
            'spectralFlatness',
            'rms',
            'energy',
          ],
          callback: extractedFeatures => {
            setFeatures(extractedFeatures);

            // ä¿å­˜å†å²è®°å½•ï¼ˆæœ€å¤š 100 æ¡ï¼‰
            setAnalysisHistory(prev => {
              const newHistory = [...prev, {
                timestamp: Date.now(),
                features: extractedFeatures,
              }];
              return newHistory.slice(-100);
            });

            // ç»˜åˆ¶ MFCC å¯è§†åŒ–
            if (extractedFeatures.mfcc && canvasRef.current) {
              drawMFCC(extractedFeatures.mfcc);
            }
          },
        });

        meydaAnalyzerRef.current.start();
        console.log('âœ… Meyda åˆ†æå™¨å¯åŠ¨æˆåŠŸ');

      } catch (err) {
        console.error('âŒ Meyda å¯åŠ¨é”™è¯¯:', err);
        setError(err.message);
        setIsAnalyzing(false);
      }
    };

    // éŸ³é¢‘æš‚åœ/ç»“æŸæ—¶åœæ­¢åˆ†æ
    const handleStop = () => {
      console.log('â¸ åœæ­¢éŸ³é¢‘åˆ†æ');
      if (meydaAnalyzerRef.current) {
        meydaAnalyzerRef.current.stop();
        setIsAnalyzing(false);
      }
    };

    // ç»‘å®šäº‹ä»¶
    audioRef.addEventListener('play', handlePlay);
    audioRef.addEventListener('pause', handleStop);
    audioRef.addEventListener('ended', handleStop);

    // æ¸…ç†å‡½æ•°
    return () => {
      console.log('ğŸ§¹ FeatureExtractor: æ¸…ç†');
      
      audioRef.removeEventListener('play', handlePlay);
      audioRef.removeEventListener('pause', handleStop);
      audioRef.removeEventListener('ended', handleStop);

      if (meydaAnalyzerRef.current) {
        meydaAnalyzerRef.current.stop();
      }

      // æ³¨æ„ï¼šä¸è¦å…³é—­ AudioContextï¼Œå› ä¸ºå®ƒä¼šè¢«å¤ç”¨
    };
  }, [audioRef]);

  // ç»˜åˆ¶ MFCC å¯è§†åŒ–
  const drawMFCC = (mfccValues) => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // æ¸…é™¤ç”»å¸ƒ
    ctx.clearRect(0, 0, width, height);

    // ç»˜åˆ¶èƒŒæ™¯
    ctx.fillStyle = '#f4f4f4';
    ctx.fillRect(0, 0, width, height);

    // ç»˜åˆ¶ MFCC ç³»æ•°ï¼ˆæŸ±çŠ¶å›¾ï¼‰
    const barWidth = width / mfccValues.length;
    const maxValue = Math.max(...mfccValues.map(Math.abs));

    mfccValues.forEach((value, index) => {
      const normalizedValue = value / maxValue;
      const barHeight = (normalizedValue * height) / 2;
      const x = index * barWidth;
      const y = height / 2 - barHeight;

      // é¢œè‰²æ¸å˜ï¼ˆè“è‰²åˆ°çº¢è‰²ï¼‰
      const hue = 240 - (index / mfccValues.length) * 240;
      ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
      ctx.fillRect(x, y, barWidth - 2, Math.abs(barHeight));
    });

    // ç»˜åˆ¶ä¸­å¿ƒçº¿
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, height / 2);
    ctx.lineTo(width, height / 2);
    ctx.stroke();
  };

  // è®¡ç®—å¹³å‡ç‰¹å¾
  const getAverageFeatures = () => {
    if (analysisHistory.length === 0) return null;

    const avgRMS = analysisHistory.reduce((sum, item) => sum + (item.features.rms || 0), 0) / analysisHistory.length;
    const avgZCR = analysisHistory.reduce((sum, item) => sum + (item.features.zcr || 0), 0) / analysisHistory.length;
    const avgSpectralCentroid = analysisHistory.reduce((sum, item) => sum + (item.features.spectralCentroid || 0), 0) / analysisHistory.length;

    return {
      avgRMS: avgRMS.toFixed(4),
      avgZCR: avgZCR.toFixed(4),
      avgSpectralCentroid: avgSpectralCentroid.toFixed(2),
    };
  };

  const averages = getAverageFeatures();

  // å¦‚æœæœ‰é”™è¯¯ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
  if (error) {
    return (
      <div style={{ padding: '1rem', background: '#f8d7da', color: '#721c24', borderRadius: '8px' }}>
        <strong>åˆ†æå™¨é”™è¯¯:</strong> {error}
      </div>
    );
  }

  // å¦‚æœæ²¡æœ‰éŸ³é¢‘æˆ–æœªå¼€å§‹åˆ†æï¼Œä¸æ˜¾ç¤º
  if (!features && !isAnalyzing) return null;

  return (
    <div className="feature-extractor">
      <div className="feature-header">
        <h3>ğŸµ éŸ³é¢‘ç‰¹å¾åˆ†æ</h3>
        {isAnalyzing && <span className="analyzing-badge">å®æ—¶åˆ†æä¸­...</span>}
      </div>

      {/* MFCC å¯è§†åŒ– */}
      {features?.mfcc && (
        <div className="mfcc-visualization">
          <h4>MFCC ç³»æ•°å¯è§†åŒ–</h4>
          <canvas 
            ref={canvasRef} 
            width={600} 
            height={150}
            style={{ width: '100%', maxWidth: '600px', border: '1px solid #ddd' }}
          />
        </div>
      )}

      {/* å®æ—¶ç‰¹å¾å€¼ */}
      {features && (
        <div className="features-grid">
          <div className="feature-card">
            <div className="feature-label">éŸ³é‡ (RMS)</div>
            <div className="feature-value">{features.rms?.toFixed(4) || 'N/A'}</div>
          </div>

          <div className="feature-card">
            <div className="feature-label">è¿‡é›¶ç‡ (ZCR)</div>
            <div className="feature-value">{features.zcr?.toFixed(4) || 'N/A'}</div>
          </div>

          <div className="feature-card">
            <div className="feature-label">é¢‘è°±è´¨å¿ƒ</div>
            <div className="feature-value">{features.spectralCentroid?.toFixed(2) || 'N/A'} Hz</div>
          </div>

          <div className="feature-card">
            <div className="feature-label">é¢‘è°±å¹³å¦åº¦</div>
            <div className="feature-value">{features.spectralFlatness?.toFixed(4) || 'N/A'}</div>
          </div>

          <div className="feature-card">
            <div className="feature-label">èƒ½é‡</div>
            <div className="feature-value">{features.energy?.toFixed(4) || 'N/A'}</div>
          </div>

          <div className="feature-card">
            <div className="feature-label">MFCC ç³»æ•°æ•°é‡</div>
            <div className="feature-value">{features.mfcc?.length || 0}</div>
          </div>
        </div>
      )}

      {/* å¹³å‡å€¼ç»Ÿè®¡ */}
      {averages && (
        <div className="average-stats">
          <h4>ğŸ“Š å¹³å‡ç»Ÿè®¡ï¼ˆåŸºäº {analysisHistory.length} ä¸ªæ ·æœ¬ï¼‰</h4>
          <div className="stats-grid">
            <div>å¹³å‡éŸ³é‡: {averages.avgRMS}</div>
            <div>å¹³å‡è¿‡é›¶ç‡: {averages.avgZCR}</div>
            <div>å¹³å‡é¢‘è°±è´¨å¿ƒ: {averages.avgSpectralCentroid} Hz</div>
          </div>
        </div>
      )}

      {/* MFCC è¯¦ç»†æ•°æ® */}
      {features?.mfcc && (
        <details className="mfcc-details">
          <summary>ğŸ” æŸ¥çœ‹å®Œæ•´ MFCC æ•°æ® ({features.mfcc.length} ä¸ªç³»æ•°)</summary>
          <pre className="mfcc-data">
            {JSON.stringify(features.mfcc.map(v => v.toFixed(4)), null, 2)}
          </pre>
        </details>
      )}

      {/* æ ·å¼ */}
      <style>{`
        .feature-extractor {
          margin-top: 2em;
          padding: 1.5em;
          background: white;
          border: 1px solid #ddd;
          border-radius: 8px;
        }

        .feature-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 1em;
        }

        .feature-header h3 {
          margin: 0;
          color: #333;
        }

        .analyzing-badge {
          background: #28a745;
          color: white;
          padding: 0.25em 0.75em;
          border-radius: 12px;
          font-size: 0.85em;
          animation: pulse 2s infinite;
        }

        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.6; }
        }

        .mfcc-visualization {
          margin-bottom: 1.5em;
        }

        .mfcc-visualization h4 {
          margin-bottom: 0.5em;
          color: #555;
        }

        .features-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          gap: 1em;
          margin-bottom: 1.5em;
        }

        .feature-card {
          background: #f8f9fa;
          padding: 1em;
          border-radius: 6px;
          border: 1px solid #e9ecef;
        }

        .feature-label {
          font-size: 0.85em;
          color: #6c757d;
          margin-bottom: 0.5em;
        }

        .feature-value {
          font-size: 1.25em;
          font-weight: bold;
          color: #007bff;
        }

        .average-stats {
          background: #e7f3ff;
          padding: 1em;
          border-radius: 6px;
          margin-bottom: 1em;
        }

        .average-stats h4 {
          margin-top: 0;
          margin-bottom: 0.75em;
          color: #0056b3;
        }

        .stats-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 0.5em;
          font-size: 0.95em;
        }

        .mfcc-details {
          margin-top: 1em;
        }

        .mfcc-details summary {
          cursor: pointer;
          padding: 0.5em;
          background: #f8f9fa;
          border-radius: 4px;
          user-select: none;
        }

        .mfcc-details summary:hover {
          background: #e9ecef;
        }

        .mfcc-data {
          background: #f4f4f4;
          padding: 1em;
          border-radius: 4px;
          overflow-x: auto;
          margin-top: 0.5em;
          font-size: 0.85em;
        }
      `}</style>
    </div>
  );
}

export default FeatureExtractor;